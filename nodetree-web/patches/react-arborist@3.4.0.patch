diff --git a/src/components/default-container.tsx b/src/components/default-container.tsx
index f92dd5cfe7463bbdb775f87afffb4052fe0d90db..6bb1f19ae37d5bf135e7330bf76ac52637683ff4 100644
--- a/src/components/default-container.tsx
+++ b/src/components/default-container.tsx
@@ -4,6 +4,11 @@ import { focusNextElement, focusPrevElement } from "../utils";
 import { ListOuterElement } from "./list-outer-element";
 import { ListInnerElement } from "./list-inner-element";
 import { RowContainer } from "./row-container";
+import { SearchForNode } from "../interfaces/commands";
+import {
+  parseKeybinding,
+  filterFalseyToString,
+} from "../interfaces/keybinding";
 
 let focusSearchTerm = "";
 let timeoutId: any = null;
@@ -42,178 +47,34 @@ export function DefaultContainer() {
         if (tree.isEditing) {
           return;
         }
-        if (e.key === "Backspace") {
-          if (!tree.props.onDelete) return;
-          const ids = Array.from(tree.selectedIds);
-          if (ids.length > 1) {
-            let nextFocus = tree.mostRecentNode;
-            while (nextFocus && nextFocus.isSelected) {
-              nextFocus = nextFocus.nextSibling;
-            }
-            if (!nextFocus) nextFocus = tree.lastNode;
-            tree.focus(nextFocus, { scroll: false });
-            tree.delete(Array.from(ids));
-          } else {
-            const node = tree.focusedNode;
-            if (node) {
-              const sib = node.nextSibling;
-              const parent = node.parent;
-              tree.focus(sib || parent, { scroll: false });
-              tree.delete(node);
-            }
-          }
-          return;
-        }
-        if (e.key === "Tab" && !e.shiftKey) {
-          e.preventDefault();
-          focusNextElement(e.currentTarget);
-          return;
-        }
-        if (e.key === "Tab" && e.shiftKey) {
-          e.preventDefault();
-          focusPrevElement(e.currentTarget);
-          return;
-        }
-        if (e.key === "ArrowDown") {
-          e.preventDefault();
-          const next = tree.nextNode;
-          if (e.metaKey) {
-            tree.select(tree.focusedNode);
-            tree.activate(tree.focusedNode);
-            return;
-          } else if (!e.shiftKey || tree.props.disableMultiSelection) {
-            tree.focus(next);
-            return;
-          } else {
-            if (!next) return;
-            const current = tree.focusedNode;
-            if (!current) {
-              tree.focus(tree.firstNode);
-            } else if (current.isSelected) {
-              tree.selectContiguous(next);
-            } else {
-              tree.selectMulti(next);
-            }
-            return;
-          }
-        }
-        if (e.key === "ArrowUp") {
-          e.preventDefault();
-          const prev = tree.prevNode;
-          if (!e.shiftKey || tree.props.disableMultiSelection) {
-            tree.focus(prev);
-            return;
-          } else {
-            if (!prev) return;
-            const current = tree.focusedNode;
-            if (!current) {
-              tree.focus(tree.lastNode); // ?
-            } else if (current.isSelected) {
-              tree.selectContiguous(prev);
-            } else {
-              tree.selectMulti(prev);
-            }
-            return;
-          }
-        }
-        if (e.key === "ArrowRight") {
-          const node = tree.focusedNode;
-          if (!node) return;
-          if (node.isInternal && node.isOpen) {
-            tree.focus(tree.nextNode);
-          } else if (node.isInternal) tree.open(node.id);
-          return;
-        }
-        if (e.key === "ArrowLeft") {
-          const node = tree.focusedNode;
-          if (!node || node.isRoot) return;
-          if (node.isInternal && node.isOpen) tree.close(node.id);
-          else if (!node.parent?.isRoot) {
-            tree.focus(node.parent);
-          }
-          return;
-        }
-        if (e.key === "a" && e.metaKey && !tree.props.disableMultiSelection) {
-          e.preventDefault();
-          tree.selectAll();
-          return;
-        }
-        if (e.key === "a" && !e.metaKey && tree.props.onCreate) {
-          tree.createLeaf();
-          return;
-        }
-        if (e.key === "A" && !e.metaKey) {
-          if (!tree.props.onCreate) return;
-          tree.createInternal();
-          return;
-        }
 
-        if (e.key === "Home") {
-          // add shift keys
-          e.preventDefault();
-          tree.focus(tree.firstNode);
-          return;
-        }
-        if (e.key === "End") {
-          // add shift keys
+        const keybinding = tree.keybinding;
+
+        const keysToControls = parseKeybinding(keybinding);
+
+        const currentKeys = [
+          e.key.toLowerCase(),
+          e.shiftKey ? "shift" : false,
+          e.metaKey ? "meta" : false,
+        ].filter(filterFalseyToString);
+
+        const matches = keysToControls.filter((keysToControl) => {
+          const keys = keysToControl[0];
+          return (
+            keys.length === currentKeys.length &&
+            keys.every((key) => currentKeys.includes(key))
+          );
+        });
+
+        if (matches.length > 0) {
           e.preventDefault();
-          tree.focus(tree.lastNode);
-          return;
-        }
-        if (e.key === "Enter") {
-          const node = tree.focusedNode;
-          if (!node) return;
-          if (!node.isEditable || !tree.props.onRename) return;
-          setTimeout(() => {
-            if (node) tree.edit(node);
+          matches.forEach((match) => {
+            const control = match[1];
+            control(tree, e);
           });
-          return;
+        } else {
+          SearchForNode(tree, e);
         }
-        if (e.key === " ") {
-          e.preventDefault();
-          const node = tree.focusedNode;
-          if (!node) return;
-          if (node.isLeaf) {
-            node.select();
-            node.activate();
-          } else {
-            node.toggle();
-          }
-          return;
-        }
-        if (e.key === "*") {
-          const node = tree.focusedNode;
-          if (!node) return;
-          tree.openSiblings(node);
-          return;
-        }
-        if (e.key === "PageUp") {
-          e.preventDefault();
-          tree.pageUp();
-          return;
-        }
-        if (e.key === "PageDown") {
-          e.preventDefault();
-          tree.pageDown();
-        }
-
-        // If they type a sequence of characters
-        // collect them. Reset them after a timeout.
-        // Use it to search the tree for a node, then focus it.
-        // Clean this up a bit later
-        clearTimeout(timeoutId);
-        focusSearchTerm += e.key;
-        timeoutId = setTimeout(() => {
-          focusSearchTerm = "";
-        }, 600);
-        const node = tree.visibleNodes.find((n) => {
-          // @ts-ignore
-          const name = n.data.name;
-          if (typeof name === "string") {
-            return name.toLowerCase().startsWith(focusSearchTerm);
-          } else return false;
-        });
-        if (node) tree.focus(node.id);
       }}
     >
       {/* @ts-ignore */}
diff --git a/src/index.ts b/src/index.ts
index 854860fb78da9d23da9bbe4859bc48500b937bd1..5428819a339f19f70ef81227a53eee093865be75 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -7,3 +7,4 @@ export * from "./interfaces/node-api";
 export * from "./interfaces/tree-api";
 export * from "./data/simple-tree";
 export * from "./hooks/use-simple-tree";
+export { DEFAULT_KEYBINDING } from "./interfaces/keybinding";
diff --git a/src/interfaces/commands.ts b/src/interfaces/commands.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6f31ecd10b068ceeb5a847b4921bad218e724509
--- /dev/null
+++ b/src/interfaces/commands.ts
@@ -0,0 +1,216 @@
+import { KeyboardEvent } from "react";
+import { TreeApi } from "../interfaces/tree-api";
+import { focusNextElement, focusPrevElement } from "../utils";
+
+export type Command = <T extends any>(
+  tree: TreeApi<T>,
+  e?: KeyboardEvent<HTMLDivElement>
+) => void;
+
+const Delete: Command = (tree) => {
+  if (!tree.props.onDelete) return;
+  const ids = Array.from(tree.selectedIds);
+  if (ids.length > 1) {
+    let nextFocus = tree.mostRecentNode;
+    while (nextFocus && nextFocus.isSelected) {
+      nextFocus = nextFocus.nextSibling;
+    }
+    if (!nextFocus) nextFocus = tree.lastNode;
+    tree.focus(nextFocus, { scroll: false });
+    tree.delete(Array.from(ids));
+  } else {
+    const node = tree.focusedNode;
+    if (node) {
+      const sib = node.nextSibling;
+      const parent = node.parent;
+      tree.focus(sib || parent, { scroll: false });
+      tree.delete(node);
+    }
+  }
+};
+
+const FocusOutsideNext: Command = (_, e) => {
+  if (!e) throw Error(`Required keyboard event`);
+  focusNextElement(e.currentTarget);
+};
+
+const FocusOutsidePrev: Command = (_, e) => {
+  if (!e) throw Error(`Required keyboard event`);
+  focusPrevElement(e.currentTarget);
+};
+
+const SelectAndActivate: Command = (tree) => {
+  tree.select(tree.focusedNode);
+  tree.activate(tree.focusedNode);
+};
+
+const FocusNext: Command = (tree) => {
+  const next = tree.nextNode;
+  tree.focus(next);
+};
+
+const FocusFirst: Command = (tree) => {
+  tree.focus(tree.firstNode);
+};
+
+const FocusPrev: Command = (tree) => {
+  tree.focus(tree.prevNode);
+};
+
+const Prev: Command = (tree) => {
+  const prev = tree.prevNode;
+  if (!prev) return;
+  if (tree.props.disableMultiSelection) {
+    tree.focus(prev);
+    return;
+  }
+  const current = tree.focusedNode;
+  if (!current) {
+    tree.focus(tree.lastNode); // ?
+  } else if (current.isSelected) {
+    tree.selectContiguous(prev);
+  } else {
+    tree.selectMulti(prev);
+  }
+};
+
+const FocusLast: Command = (tree) => {
+  tree.focus(tree.lastNode);
+};
+
+const Next: Command = (tree) => {
+  const next = tree.nextNode;
+  if (tree.props.disableMultiSelection) {
+    tree.focus(next);
+    return;
+  }
+
+  const current = tree.focusedNode;
+  if (!current) {
+    tree.focus(tree.firstNode);
+  } else if (current.isSelected) {
+    tree.selectContiguous(next);
+  } else {
+    tree.selectMulti(next);
+  }
+};
+
+const Right: Command = (tree) => {
+  const node = tree.focusedNode;
+  if (!node) return;
+  if (node.isInternal && node.isOpen) {
+    tree.focus(tree.nextNode);
+  } else if (node.isInternal) {
+    tree.open(node.id);
+  }
+};
+
+const Left: Command = (tree) => {
+  const node = tree.focusedNode;
+  if (!node || node.isRoot) return;
+  if (node.isInternal && node.isOpen) {
+    tree.close(node.id);
+  } else if (!node.parent?.isRoot) {
+    tree.focus(node.parent);
+  }
+};
+
+const SelectAll: Command = (tree) => {
+  tree.selectAll();
+};
+
+const CreateLeaf: Command = (tree) => {
+  if (!tree.props.onCreate) return;
+  tree.createLeaf();
+};
+
+const CreateInternal: Command = (tree) => {
+  if (!tree.props.onCreate) return;
+  tree.createInternal();
+};
+
+const Rename: Command = (tree) => {
+  if (!tree.props.onRename) return;
+  setTimeout(() => {
+    if (tree.focusedNode) tree.edit(tree.focusedNode);
+  });
+};
+
+const SelectOrToggle: Command = (tree) => {
+  const node = tree.focusedNode;
+  if (!node) return;
+  if (node.isLeaf) {
+    node.select();
+    node.activate();
+  } else {
+    node.toggle();
+  }
+};
+
+const OpenSiblings: Command = (tree) => {
+  const node = tree.focusedNode;
+  if (!node) return;
+  tree.openSiblings(node);
+};
+
+const PageUp: Command = (tree) => {
+  tree.pageUp();
+};
+
+const PageDown: Command = (tree) => {
+  tree.pageDown();
+};
+
+export const commands = {
+  Delete,
+  SelectAndActivate,
+  FocusOutsideNext,
+  FocusOutsidePrev,
+  FocusNext,
+  FocusPrev,
+  FocusFirst,
+  FocusLast,
+  Next,
+  Prev,
+  Right,
+  Left,
+  SelectAll,
+  CreateLeaf,
+  CreateInternal,
+  Rename,
+  SelectOrToggle,
+  OpenSiblings,
+  PageUp,
+  PageDown,
+} as const;
+
+export const SearchForNode = (() => {
+  // variables for the closure
+  let focusSearchTerm = "";
+  let timeoutId: NodeJS.Timeout | null = null;
+
+  return <T extends any>(
+    tree: TreeApi<T>,
+    e: KeyboardEvent<HTMLDivElement>
+  ) => {
+    // If they type a sequence of characters
+    // collect them. Reset them after a timeout.
+    // Use it to search the tree for a node, then focus it.
+    // Clean this up a bit later
+    if (timeoutId) {
+      clearTimeout(timeoutId);
+    }
+    focusSearchTerm += e.key;
+    timeoutId = setTimeout(() => {
+      focusSearchTerm = "";
+    }, 600);
+    const node = tree.visibleNodes.find((n) => {
+      // @ts-ignore
+      const name = n.data.name;
+      if (typeof name === "string") {
+        return name.toLowerCase().startsWith(focusSearchTerm);
+      } else return false;
+    });
+    if (node) tree.focus(node.id);
+  };
+})();
diff --git a/src/interfaces/keybinding.ts b/src/interfaces/keybinding.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c4231db86fd91f7c84338f1f2a8044ac3c32119f
--- /dev/null
+++ b/src/interfaces/keybinding.ts
@@ -0,0 +1,35 @@
+import { commands, Command } from "./commands";
+
+export type Keybinding = Record<string, keyof typeof commands>;
+
+export const DEFAULT_KEYBINDING: Keybinding = {
+  Backspace: "Delete",
+  Tab: "FocusOutsideNext",
+  "Tab+shift": "FocusOutsidePrev",
+  "ArrowDown+meta": "SelectAndActivate",
+  ArrowDown: "Next",
+  ArrowUp: "Prev",
+  ArrowRight: "Right",
+  ArrowLeft: "Left",
+  "a+meta": "SelectAll",
+  a: "CreateLeaf",
+  A: "CreateInternal",
+  Home: "FocusFirst",
+  End: "FocusLast",
+  Enter: "Rename",
+  " ": "SelectOrToggle",
+  "*": "OpenSiblings",
+  PageUp: "PageUp",
+  PageDown: "PageDown",
+};
+
+export const filterFalseyToString = (key: unknown): key is string => !!key;
+
+type KeysToControl = [string[], Command];
+
+export const parseKeybinding = (keybinding: Keybinding): KeysToControl[] =>
+  Object.keys(keybinding).reduce((acc, key) => {
+    const keys = key.toLowerCase().split(/[ +]/g).filter(filterFalseyToString);
+    acc.push([keys, commands[keybinding[key]]]);
+    return acc;
+  }, [] as KeysToControl[]);
diff --git a/src/interfaces/tree-api.ts b/src/interfaces/tree-api.ts
index 50e03a8414191a4673f18cdafada6154f257777c..18c2efb78efff6481e1a73b10ab7c85f12de3e30 100644
--- a/src/interfaces/tree-api.ts
+++ b/src/interfaces/tree-api.ts
@@ -21,6 +21,7 @@ import { Cursor } from "../dnd/compute-drop";
 import { Store } from "redux";
 import { createList } from "../data/create-list";
 import { createIndex } from "../data/create-index";
+import { DEFAULT_KEYBINDING, Keybinding } from "./keybinding";
 
 const { safeRun, identify, identifyNull } = utils;
 export class TreeApi<T> {
@@ -622,6 +623,10 @@ export class TreeApi<T> {
     return id === destinationParentId && destinationIndex === null;
   }
 
+  get keybinding(): Keybinding {
+    return this.props.keybinding || DEFAULT_KEYBINDING;
+  }
+
   /* Tree Event Handlers */
 
   onFocus() {
diff --git a/src/types/tree-props.ts b/src/types/tree-props.ts
index 440bcc40304d7bf02bdd0b7bf2449f2b248d48c7..f8d1ef9fa962c9f656082989964f626c9f1c02cd 100644
--- a/src/types/tree-props.ts
+++ b/src/types/tree-props.ts
@@ -4,8 +4,9 @@ import * as renderers from "./renderers";
 import { ElementType, MouseEventHandler } from "react";
 import { ListOnScrollProps } from "react-window";
 import { NodeApi } from "../interfaces/node-api";
-import { OpenMap } from "../state/open-slice";
 import { useDragDropManager } from "react-dnd";
+import { OpenMap, OpenSlice } from "../state/open-slice";
+import { Keybinding } from "../interfaces/keybinding";
 
 export interface TreeProps<T> {
   /* Data Options */
@@ -73,6 +74,9 @@ export interface TreeProps<T> {
   className?: string | undefined;
   rowClassName?: string | undefined;
 
+  /* Keybinding */
+  keybinding?: Keybinding;
+
   dndRootElement?: globalThis.Node | null;
   onClick?: MouseEventHandler;
   onContextMenu?: MouseEventHandler;
