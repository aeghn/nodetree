diff --git a/dist/main/components/default-container.js b/dist/main/components/default-container.js
index 58ce20b9b1ffdfa9abdd0a6eb60149bd75db23f9..52ed7f415e959f08ff16e36790ea4e740b25c671 100644
--- a/dist/main/components/default-container.js
+++ b/dist/main/components/default-container.js
@@ -16,223 +16,230 @@ let timeoutId = null;
  * the event handler. Future clean up welcome.
  */
 function DefaultContainer() {
-    (0, context_1.useDataUpdates)();
-    const tree = (0, context_1.useTreeApi)();
-    return ((0, jsx_runtime_1.jsx)("div", { role: "tree", style: {
-            height: tree.height,
-            width: tree.width,
-            minHeight: 0,
-            minWidth: 0,
-        }, onContextMenu: tree.props.onContextMenu, onClick: tree.props.onClick, tabIndex: 0, onFocus: (e) => {
-            if (!e.currentTarget.contains(e.relatedTarget)) {
-                tree.onFocus();
-            }
-        }, onBlur: (e) => {
-            if (!e.currentTarget.contains(e.relatedTarget)) {
-                tree.onBlur();
-            }
-        }, onKeyDown: (e) => {
-            var _a;
-            if (tree.isEditing) {
-                return;
-            }
-            if (e.key === "Backspace") {
-                if (!tree.props.onDelete)
-                    return;
-                const ids = Array.from(tree.selectedIds);
-                if (ids.length > 1) {
-                    let nextFocus = tree.mostRecentNode;
-                    while (nextFocus && nextFocus.isSelected) {
-                        nextFocus = nextFocus.nextSibling;
-                    }
-                    if (!nextFocus)
-                        nextFocus = tree.lastNode;
-                    tree.focus(nextFocus, { scroll: false });
-                    tree.delete(Array.from(ids));
-                }
-                else {
-                    const node = tree.focusedNode;
-                    if (node) {
-                        const sib = node.nextSibling;
-                        const parent = node.parent;
-                        tree.focus(sib || parent, { scroll: false });
-                        tree.delete(node);
-                    }
-                }
-                return;
-            }
-            if (e.key === "Tab" && !e.shiftKey) {
-                e.preventDefault();
-                (0, utils_1.focusNextElement)(e.currentTarget);
-                return;
-            }
-            if (e.key === "Tab" && e.shiftKey) {
-                e.preventDefault();
-                (0, utils_1.focusPrevElement)(e.currentTarget);
-                return;
-            }
-            if (e.key === "ArrowDown") {
-                e.preventDefault();
-                const next = tree.nextNode;
-                if (e.metaKey) {
-                    tree.select(tree.focusedNode);
-                    tree.activate(tree.focusedNode);
-                    return;
-                }
-                else if (!e.shiftKey || tree.props.disableMultiSelection) {
-                    tree.focus(next);
-                    return;
-                }
-                else {
-                    if (!next)
-                        return;
-                    const current = tree.focusedNode;
-                    if (!current) {
-                        tree.focus(tree.firstNode);
-                    }
-                    else if (current.isSelected) {
-                        tree.selectContiguous(next);
-                    }
-                    else {
-                        tree.selectMulti(next);
-                    }
-                    return;
-                }
-            }
-            if (e.key === "ArrowUp") {
-                e.preventDefault();
-                const prev = tree.prevNode;
-                if (!e.shiftKey || tree.props.disableMultiSelection) {
-                    tree.focus(prev);
-                    return;
-                }
-                else {
-                    if (!prev)
-                        return;
-                    const current = tree.focusedNode;
-                    if (!current) {
-                        tree.focus(tree.lastNode); // ?
-                    }
-                    else if (current.isSelected) {
-                        tree.selectContiguous(prev);
-                    }
-                    else {
-                        tree.selectMulti(prev);
-                    }
-                    return;
-                }
-            }
-            if (e.key === "ArrowRight") {
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                if (node.isInternal && node.isOpen) {
-                    tree.focus(tree.nextNode);
-                }
-                else if (node.isInternal)
-                    tree.open(node.id);
-                return;
-            }
-            if (e.key === "ArrowLeft") {
-                const node = tree.focusedNode;
-                if (!node || node.isRoot)
-                    return;
-                if (node.isInternal && node.isOpen)
-                    tree.close(node.id);
-                else if (!((_a = node.parent) === null || _a === void 0 ? void 0 : _a.isRoot)) {
-                    tree.focus(node.parent);
-                }
-                return;
-            }
-            if (e.key === "a" && e.metaKey && !tree.props.disableMultiSelection) {
-                e.preventDefault();
-                tree.selectAll();
-                return;
-            }
-            if (e.key === "a" && !e.metaKey && tree.props.onCreate) {
-                tree.createLeaf();
-                return;
-            }
-            if (e.key === "A" && !e.metaKey) {
-                if (!tree.props.onCreate)
-                    return;
-                tree.createInternal();
-                return;
-            }
-            if (e.key === "Home") {
-                // add shift keys
-                e.preventDefault();
-                tree.focus(tree.firstNode);
-                return;
-            }
-            if (e.key === "End") {
-                // add shift keys
-                e.preventDefault();
-                tree.focus(tree.lastNode);
-                return;
-            }
-            if (e.key === "Enter") {
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                if (!node.isEditable || !tree.props.onRename)
-                    return;
-                setTimeout(() => {
-                    if (node)
-                        tree.edit(node);
-                });
-                return;
-            }
-            if (e.key === " ") {
-                e.preventDefault();
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                if (node.isLeaf) {
-                    node.select();
-                    node.activate();
-                }
-                else {
-                    node.toggle();
-                }
-                return;
-            }
-            if (e.key === "*") {
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                tree.openSiblings(node);
-                return;
-            }
-            if (e.key === "PageUp") {
-                e.preventDefault();
-                tree.pageUp();
-                return;
-            }
-            if (e.key === "PageDown") {
-                e.preventDefault();
-                tree.pageDown();
-            }
-            // If they type a sequence of characters
-            // collect them. Reset them after a timeout.
-            // Use it to search the tree for a node, then focus it.
-            // Clean this up a bit later
-            clearTimeout(timeoutId);
-            focusSearchTerm += e.key;
-            timeoutId = setTimeout(() => {
-                focusSearchTerm = "";
-            }, 600);
-            const node = tree.visibleNodes.find((n) => {
-                // @ts-ignore
-                const name = n.data.name;
-                if (typeof name === "string") {
-                    return name.toLowerCase().startsWith(focusSearchTerm);
-                }
-                else
-                    return false;
-            });
-            if (node)
-                tree.focus(node.id);
-        }, children: (0, jsx_runtime_1.jsx)(react_window_1.FixedSizeList, { className: tree.props.className, outerRef: tree.listEl, itemCount: tree.visibleNodes.length, height: tree.height, width: tree.width, itemSize: tree.rowHeight, overscanCount: tree.overscanCount, itemKey: (index) => { var _a; return ((_a = tree.visibleNodes[index]) === null || _a === void 0 ? void 0 : _a.id) || index; }, outerElementType: list_outer_element_1.ListOuterElement, innerElementType: list_inner_element_1.ListInnerElement, onScroll: tree.props.onScroll, onItemsRendered: tree.onItemsRendered.bind(tree), ref: tree.list, children: row_container_1.RowContainer }) }));
+  (0, context_1.useDataUpdates)();
+  const tree = (0, context_1.useTreeApi)();
+  return (0, jsx_runtime_1.jsx)("div", {
+    role: "tree",
+    style: {
+      height: tree.height,
+      width: tree.width,
+      minHeight: 0,
+      minWidth: 0,
+    },
+    onContextMenu: tree.props.onContextMenu,
+    onClick: tree.props.onClick,
+    tabIndex: 0,
+    onFocus: (e) => {
+      if (!e.currentTarget.contains(e.relatedTarget)) {
+        tree.onFocus();
+      }
+    },
+    onBlur: (e) => {
+      if (!e.currentTarget.contains(e.relatedTarget)) {
+        tree.onBlur();
+      }
+    },
+    onKeyDown: (e) => {
+      var _a;
+      if (tree.isEditing) {
+        return;
+      }
+      if (e.key === "Backspace") {
+        if (!tree.props.onDelete) return;
+        const ids = Array.from(tree.selectedIds);
+        if (ids.length > 1) {
+          let nextFocus = tree.mostRecentNode;
+          while (nextFocus && nextFocus.isSelected) {
+            nextFocus = nextFocus.nextSibling;
+          }
+          if (!nextFocus) nextFocus = tree.lastNode;
+          tree.focus(nextFocus, { scroll: false });
+          tree.delete(Array.from(ids));
+        } else {
+          const node = tree.focusedNode;
+          if (node) {
+            const sib = node.nextSibling;
+            const parent = node.parent;
+            tree.focus(sib || parent, { scroll: false });
+            tree.delete(node);
+          }
+        }
+        return;
+      }
+      if (e.key === "Tab" && !e.shiftKey) {
+        e.preventDefault();
+        (0, utils_1.focusNextElement)(e.currentTarget);
+        return;
+      }
+      if (e.key === "Tab" && e.shiftKey) {
+        e.preventDefault();
+        (0, utils_1.focusPrevElement)(e.currentTarget);
+        return;
+      }
+      if (e.key === "ArrowDown") {
+        e.preventDefault();
+        const next = tree.nextNode;
+        if (e.ctrlKey) {
+          tree.select(tree.focusedNode);
+          tree.activate(tree.focusedNode);
+          return;
+        } else if (!e.shiftKey || tree.props.disableMultiSelection) {
+          tree.focus(next);
+          return;
+        } else {
+          if (!next) return;
+          const current = tree.focusedNode;
+          if (!current) {
+            tree.focus(tree.firstNode);
+          } else if (current.isSelected) {
+            tree.selectContiguous(next);
+          } else {
+            tree.selectMulti(next);
+          }
+          return;
+        }
+      }
+      if (e.key === "ArrowUp") {
+        e.preventDefault();
+        const prev = tree.prevNode;
+        if (!e.shiftKey || tree.props.disableMultiSelection) {
+          tree.focus(prev);
+          return;
+        } else {
+          if (!prev) return;
+          const current = tree.focusedNode;
+          if (!current) {
+            tree.focus(tree.lastNode); // ?
+          } else if (current.isSelected) {
+            tree.selectContiguous(prev);
+          } else {
+            tree.selectMulti(prev);
+          }
+          return;
+        }
+      }
+      if (e.key === "ArrowRight") {
+        const node = tree.focusedNode;
+        if (!node) return;
+        if (node.isInternal && node.isOpen) {
+          tree.focus(tree.nextNode);
+        } else if (node.isInternal) tree.open(node.id);
+        return;
+      }
+      if (e.key === "ArrowLeft") {
+        const node = tree.focusedNode;
+        if (!node || node.isRoot) return;
+        if (node.isInternal && node.isOpen) tree.close(node.id);
+        else if (
+          !((_a = node.parent) === null || _a === void 0 ? void 0 : _a.isRoot)
+        ) {
+          tree.focus(node.parent);
+        }
+        return;
+      }
+      if (e.key === "a" && e.ctrlKey && !tree.props.disableMultiSelection) {
+        e.preventDefault();
+        tree.selectAll();
+        return;
+      }
+      if (e.key === "a" && !e.ctrlKey && tree.props.onCreate) {
+        tree.createLeaf();
+        return;
+      }
+      if (e.key === "A" && !e.ctrlKey) {
+        if (!tree.props.onCreate) return;
+        tree.createInternal();
+        return;
+      }
+      if (e.key === "Home") {
+        // add shift keys
+        e.preventDefault();
+        tree.focus(tree.firstNode);
+        return;
+      }
+      if (e.key === "End") {
+        // add shift keys
+        e.preventDefault();
+        tree.focus(tree.lastNode);
+        return;
+      }
+      if (e.key === "Enter") {
+        const node = tree.focusedNode;
+        if (!node) return;
+        if (!node.isEditable || !tree.props.onRename) return;
+        setTimeout(() => {
+          if (node) tree.edit(node);
+        });
+        return;
+      }
+      if (e.key === " ") {
+        e.preventDefault();
+        const node = tree.focusedNode;
+        if (!node) return;
+        if (node.isLeaf) {
+          node.select();
+          node.activate();
+        } else {
+          node.toggle();
+        }
+        return;
+      }
+      if (e.key === "*") {
+        const node = tree.focusedNode;
+        if (!node) return;
+        tree.openSiblings(node);
+        return;
+      }
+      if (e.key === "PageUp") {
+        e.preventDefault();
+        tree.pageUp();
+        return;
+      }
+      if (e.key === "PageDown") {
+        e.preventDefault();
+        tree.pageDown();
+      }
+      // If they type a sequence of characters
+      // collect them. Reset them after a timeout.
+      // Use it to search the tree for a node, then focus it.
+      // Clean this up a bit later
+      clearTimeout(timeoutId);
+      focusSearchTerm += e.key;
+      timeoutId = setTimeout(() => {
+        focusSearchTerm = "";
+      }, 600);
+      const node = tree.visibleNodes.find((n) => {
+        // @ts-ignore
+        const name = n.data.name;
+        if (typeof name === "string") {
+          return name.toLowerCase().startsWith(focusSearchTerm);
+        } else return false;
+      });
+      if (node) tree.focus(node.id);
+    },
+    children: (0, jsx_runtime_1.jsx)(react_window_1.FixedSizeList, {
+      className: tree.props.className,
+      outerRef: tree.listEl,
+      itemCount: tree.visibleNodes.length,
+      height: tree.height,
+      width: tree.width,
+      itemSize: tree.rowHeight,
+      overscanCount: tree.overscanCount,
+      itemKey: (index) => {
+        var _a;
+        return (
+          ((_a = tree.visibleNodes[index]) === null || _a === void 0
+            ? void 0
+            : _a.id) || index
+        );
+      },
+      outerElementType: list_outer_element_1.ListOuterElement,
+      innerElementType: list_inner_element_1.ListInnerElement,
+      onScroll: tree.props.onScroll,
+      onItemsRendered: tree.onItemsRendered.bind(tree),
+      ref: tree.list,
+      children: row_container_1.RowContainer,
+    }),
+  });
 }
 exports.DefaultContainer = DefaultContainer;
diff --git a/dist/main/interfaces/node-api.js b/dist/main/interfaces/node-api.js
index 120c7388c24b757705aba64b4d16f36cde93accf..3b0b5b93a8d5e61c02f087468f882ff1f1623e3c 100644
--- a/dist/main/interfaces/node-api.js
+++ b/dist/main/interfaces/node-api.js
@@ -3,162 +3,166 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.NodeApi = void 0;
 const create_root_1 = require("../data/create-root");
 class NodeApi {
-    constructor(params) {
-        this.handleClick = (e) => {
-            if (e.metaKey && !this.tree.props.disableMultiSelection) {
-                this.isSelected ? this.deselect() : this.selectMulti();
-            }
-            else if (e.shiftKey && !this.tree.props.disableMultiSelection) {
-                this.selectContiguous();
-            }
-            else {
-                this.select();
-                this.activate();
-            }
-        };
-        this.tree = params.tree;
-        this.id = params.id;
-        this.data = params.data;
-        this.level = params.level;
-        this.children = params.children;
-        this.parent = params.parent;
-        this.isDraggable = params.isDraggable;
-        this.rowIndex = params.rowIndex;
-    }
-    get isRoot() {
-        return this.id === create_root_1.ROOT_ID;
-    }
-    get isLeaf() {
-        return !Array.isArray(this.children);
-    }
-    get isInternal() {
-        return !this.isLeaf;
-    }
-    get isOpen() {
-        return this.isLeaf ? false : this.tree.isOpen(this.id);
-    }
-    get isClosed() {
-        return this.isLeaf ? false : !this.tree.isOpen(this.id);
-    }
-    get isEditable() {
-        return this.tree.isEditable(this.data);
-    }
-    get isEditing() {
-        return this.tree.editingId === this.id;
-    }
-    get isSelected() {
-        return this.tree.isSelected(this.id);
-    }
-    get isOnlySelection() {
-        return this.isSelected && this.tree.hasOneSelection;
-    }
-    get isSelectedStart() {
-        var _a;
-        return this.isSelected && !((_a = this.prev) === null || _a === void 0 ? void 0 : _a.isSelected);
-    }
-    get isSelectedEnd() {
-        var _a;
-        return this.isSelected && !((_a = this.next) === null || _a === void 0 ? void 0 : _a.isSelected);
-    }
-    get isFocused() {
-        return this.tree.isFocused(this.id);
-    }
-    get isDragging() {
-        return this.tree.isDragging(this.id);
-    }
-    get willReceiveDrop() {
-        return this.tree.willReceiveDrop(this.id);
-    }
-    get state() {
-        return {
-            isClosed: this.isClosed,
-            isDragging: this.isDragging,
-            isEditing: this.isEditing,
-            isFocused: this.isFocused,
-            isInternal: this.isInternal,
-            isLeaf: this.isLeaf,
-            isOpen: this.isOpen,
-            isSelected: this.isSelected,
-            isSelectedEnd: this.isSelectedEnd,
-            isSelectedStart: this.isSelectedStart,
-            willReceiveDrop: this.willReceiveDrop,
-        };
-    }
-    get childIndex() {
-        if (this.parent && this.parent.children) {
-            return this.parent.children.findIndex((child) => child.id === this.id);
-        }
-        else {
-            return -1;
-        }
-    }
-    get next() {
-        if (this.rowIndex === null)
-            return null;
-        return this.tree.at(this.rowIndex + 1);
-    }
-    get prev() {
-        if (this.rowIndex === null)
-            return null;
-        return this.tree.at(this.rowIndex - 1);
-    }
-    get nextSibling() {
-        var _a, _b;
-        const i = this.childIndex;
-        return (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children[i + 1]) !== null && _b !== void 0 ? _b : null;
-    }
-    isAncestorOf(node) {
-        if (!node)
-            return false;
-        let ancestor = node;
-        while (ancestor) {
-            if (ancestor.id === this.id)
-                return true;
-            ancestor = ancestor.parent;
-        }
-        return false;
-    }
-    select() {
-        this.tree.select(this);
-    }
-    deselect() {
-        this.tree.deselect(this);
-    }
-    selectMulti() {
-        this.tree.selectMulti(this);
-    }
-    selectContiguous() {
-        this.tree.selectContiguous(this);
-    }
-    activate() {
-        this.tree.activate(this);
-    }
-    focus() {
-        this.tree.focus(this);
-    }
-    toggle() {
-        this.tree.toggle(this);
-    }
-    open() {
-        this.tree.open(this);
-    }
-    openParents() {
-        this.tree.openParents(this);
-    }
-    close() {
-        this.tree.close(this);
-    }
-    submit(value) {
-        this.tree.submit(this, value);
-    }
-    reset() {
-        this.tree.reset();
-    }
-    clone() {
-        return new NodeApi(Object.assign({}, this));
-    }
-    edit() {
-        return this.tree.edit(this);
-    }
+  constructor(params) {
+    this.handleClick = (e) => {
+      if (e.ctrlKey && !this.tree.props.disableMultiSelection) {
+        this.isSelected ? this.deselect() : this.selectMulti();
+      } else if (e.shiftKey && !this.tree.props.disableMultiSelection) {
+        this.selectContiguous();
+      } else {
+        this.select();
+        this.activate();
+      }
+    };
+    this.tree = params.tree;
+    this.id = params.id;
+    this.data = params.data;
+    this.level = params.level;
+    this.children = params.children;
+    this.parent = params.parent;
+    this.isDraggable = params.isDraggable;
+    this.rowIndex = params.rowIndex;
+  }
+  get isRoot() {
+    return this.id === create_root_1.ROOT_ID;
+  }
+  get isLeaf() {
+    return !Array.isArray(this.children);
+  }
+  get isInternal() {
+    return !this.isLeaf;
+  }
+  get isOpen() {
+    return this.isLeaf ? false : this.tree.isOpen(this.id);
+  }
+  get isClosed() {
+    return this.isLeaf ? false : !this.tree.isOpen(this.id);
+  }
+  get isEditable() {
+    return this.tree.isEditable(this.data);
+  }
+  get isEditing() {
+    return this.tree.editingId === this.id;
+  }
+  get isSelected() {
+    return this.tree.isSelected(this.id);
+  }
+  get isOnlySelection() {
+    return this.isSelected && this.tree.hasOneSelection;
+  }
+  get isSelectedStart() {
+    var _a;
+    return (
+      this.isSelected &&
+      !((_a = this.prev) === null || _a === void 0 ? void 0 : _a.isSelected)
+    );
+  }
+  get isSelectedEnd() {
+    var _a;
+    return (
+      this.isSelected &&
+      !((_a = this.next) === null || _a === void 0 ? void 0 : _a.isSelected)
+    );
+  }
+  get isFocused() {
+    return this.tree.isFocused(this.id);
+  }
+  get isDragging() {
+    return this.tree.isDragging(this.id);
+  }
+  get willReceiveDrop() {
+    return this.tree.willReceiveDrop(this.id);
+  }
+  get state() {
+    return {
+      isClosed: this.isClosed,
+      isDragging: this.isDragging,
+      isEditing: this.isEditing,
+      isFocused: this.isFocused,
+      isInternal: this.isInternal,
+      isLeaf: this.isLeaf,
+      isOpen: this.isOpen,
+      isSelected: this.isSelected,
+      isSelectedEnd: this.isSelectedEnd,
+      isSelectedStart: this.isSelectedStart,
+      willReceiveDrop: this.willReceiveDrop,
+    };
+  }
+  get childIndex() {
+    if (this.parent && this.parent.children) {
+      return this.parent.children.findIndex((child) => child.id === this.id);
+    } else {
+      return -1;
+    }
+  }
+  get next() {
+    if (this.rowIndex === null) return null;
+    return this.tree.at(this.rowIndex + 1);
+  }
+  get prev() {
+    if (this.rowIndex === null) return null;
+    return this.tree.at(this.rowIndex - 1);
+  }
+  get nextSibling() {
+    var _a, _b;
+    const i = this.childIndex;
+    return (_b =
+      (_a = this.parent) === null || _a === void 0
+        ? void 0
+        : _a.children[i + 1]) !== null && _b !== void 0
+      ? _b
+      : null;
+  }
+  isAncestorOf(node) {
+    if (!node) return false;
+    let ancestor = node;
+    while (ancestor) {
+      if (ancestor.id === this.id) return true;
+      ancestor = ancestor.parent;
+    }
+    return false;
+  }
+  select() {
+    this.tree.select(this);
+  }
+  deselect() {
+    this.tree.deselect(this);
+  }
+  selectMulti() {
+    this.tree.selectMulti(this);
+  }
+  selectContiguous() {
+    this.tree.selectContiguous(this);
+  }
+  activate() {
+    this.tree.activate(this);
+  }
+  focus() {
+    this.tree.focus(this);
+  }
+  toggle() {
+    this.tree.toggle(this);
+  }
+  open() {
+    this.tree.open(this);
+  }
+  openParents() {
+    this.tree.openParents(this);
+  }
+  close() {
+    this.tree.close(this);
+  }
+  submit(value) {
+    this.tree.submit(this, value);
+  }
+  reset() {
+    this.tree.reset();
+  }
+  clone() {
+    return new NodeApi(Object.assign({}, this));
+  }
+  edit() {
+    return this.tree.edit(this);
+  }
 }
 exports.NodeApi = NodeApi;
diff --git a/dist/module/components/default-container.js b/dist/module/components/default-container.js
index 47724f59b482454fe3144dbb98bd16d3df6a9c17..52b6054d65e98152a2c7cebbc06b1dd32d0b031f 100644
--- a/dist/module/components/default-container.js
+++ b/dist/module/components/default-container.js
@@ -13,222 +13,229 @@ let timeoutId = null;
  * the event handler. Future clean up welcome.
  */
 export function DefaultContainer() {
-    useDataUpdates();
-    const tree = useTreeApi();
-    return (_jsx("div", { role: "tree", style: {
-            height: tree.height,
-            width: tree.width,
-            minHeight: 0,
-            minWidth: 0,
-        }, onContextMenu: tree.props.onContextMenu, onClick: tree.props.onClick, tabIndex: 0, onFocus: (e) => {
-            if (!e.currentTarget.contains(e.relatedTarget)) {
-                tree.onFocus();
-            }
-        }, onBlur: (e) => {
-            if (!e.currentTarget.contains(e.relatedTarget)) {
-                tree.onBlur();
-            }
-        }, onKeyDown: (e) => {
-            var _a;
-            if (tree.isEditing) {
-                return;
-            }
-            if (e.key === "Backspace") {
-                if (!tree.props.onDelete)
-                    return;
-                const ids = Array.from(tree.selectedIds);
-                if (ids.length > 1) {
-                    let nextFocus = tree.mostRecentNode;
-                    while (nextFocus && nextFocus.isSelected) {
-                        nextFocus = nextFocus.nextSibling;
-                    }
-                    if (!nextFocus)
-                        nextFocus = tree.lastNode;
-                    tree.focus(nextFocus, { scroll: false });
-                    tree.delete(Array.from(ids));
-                }
-                else {
-                    const node = tree.focusedNode;
-                    if (node) {
-                        const sib = node.nextSibling;
-                        const parent = node.parent;
-                        tree.focus(sib || parent, { scroll: false });
-                        tree.delete(node);
-                    }
-                }
-                return;
-            }
-            if (e.key === "Tab" && !e.shiftKey) {
-                e.preventDefault();
-                focusNextElement(e.currentTarget);
-                return;
-            }
-            if (e.key === "Tab" && e.shiftKey) {
-                e.preventDefault();
-                focusPrevElement(e.currentTarget);
-                return;
-            }
-            if (e.key === "ArrowDown") {
-                e.preventDefault();
-                const next = tree.nextNode;
-                if (e.metaKey) {
-                    tree.select(tree.focusedNode);
-                    tree.activate(tree.focusedNode);
-                    return;
-                }
-                else if (!e.shiftKey || tree.props.disableMultiSelection) {
-                    tree.focus(next);
-                    return;
-                }
-                else {
-                    if (!next)
-                        return;
-                    const current = tree.focusedNode;
-                    if (!current) {
-                        tree.focus(tree.firstNode);
-                    }
-                    else if (current.isSelected) {
-                        tree.selectContiguous(next);
-                    }
-                    else {
-                        tree.selectMulti(next);
-                    }
-                    return;
-                }
-            }
-            if (e.key === "ArrowUp") {
-                e.preventDefault();
-                const prev = tree.prevNode;
-                if (!e.shiftKey || tree.props.disableMultiSelection) {
-                    tree.focus(prev);
-                    return;
-                }
-                else {
-                    if (!prev)
-                        return;
-                    const current = tree.focusedNode;
-                    if (!current) {
-                        tree.focus(tree.lastNode); // ?
-                    }
-                    else if (current.isSelected) {
-                        tree.selectContiguous(prev);
-                    }
-                    else {
-                        tree.selectMulti(prev);
-                    }
-                    return;
-                }
-            }
-            if (e.key === "ArrowRight") {
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                if (node.isInternal && node.isOpen) {
-                    tree.focus(tree.nextNode);
-                }
-                else if (node.isInternal)
-                    tree.open(node.id);
-                return;
-            }
-            if (e.key === "ArrowLeft") {
-                const node = tree.focusedNode;
-                if (!node || node.isRoot)
-                    return;
-                if (node.isInternal && node.isOpen)
-                    tree.close(node.id);
-                else if (!((_a = node.parent) === null || _a === void 0 ? void 0 : _a.isRoot)) {
-                    tree.focus(node.parent);
-                }
-                return;
-            }
-            if (e.key === "a" && e.metaKey && !tree.props.disableMultiSelection) {
-                e.preventDefault();
-                tree.selectAll();
-                return;
-            }
-            if (e.key === "a" && !e.metaKey && tree.props.onCreate) {
-                tree.createLeaf();
-                return;
-            }
-            if (e.key === "A" && !e.metaKey) {
-                if (!tree.props.onCreate)
-                    return;
-                tree.createInternal();
-                return;
-            }
-            if (e.key === "Home") {
-                // add shift keys
-                e.preventDefault();
-                tree.focus(tree.firstNode);
-                return;
-            }
-            if (e.key === "End") {
-                // add shift keys
-                e.preventDefault();
-                tree.focus(tree.lastNode);
-                return;
-            }
-            if (e.key === "Enter") {
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                if (!node.isEditable || !tree.props.onRename)
-                    return;
-                setTimeout(() => {
-                    if (node)
-                        tree.edit(node);
-                });
-                return;
-            }
-            if (e.key === " ") {
-                e.preventDefault();
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                if (node.isLeaf) {
-                    node.select();
-                    node.activate();
-                }
-                else {
-                    node.toggle();
-                }
-                return;
-            }
-            if (e.key === "*") {
-                const node = tree.focusedNode;
-                if (!node)
-                    return;
-                tree.openSiblings(node);
-                return;
-            }
-            if (e.key === "PageUp") {
-                e.preventDefault();
-                tree.pageUp();
-                return;
-            }
-            if (e.key === "PageDown") {
-                e.preventDefault();
-                tree.pageDown();
-            }
-            // If they type a sequence of characters
-            // collect them. Reset them after a timeout.
-            // Use it to search the tree for a node, then focus it.
-            // Clean this up a bit later
-            clearTimeout(timeoutId);
-            focusSearchTerm += e.key;
-            timeoutId = setTimeout(() => {
-                focusSearchTerm = "";
-            }, 600);
-            const node = tree.visibleNodes.find((n) => {
-                // @ts-ignore
-                const name = n.data.name;
-                if (typeof name === "string") {
-                    return name.toLowerCase().startsWith(focusSearchTerm);
-                }
-                else
-                    return false;
-            });
-            if (node)
-                tree.focus(node.id);
-        }, children: _jsx(FixedSizeList, { className: tree.props.className, outerRef: tree.listEl, itemCount: tree.visibleNodes.length, height: tree.height, width: tree.width, itemSize: tree.rowHeight, overscanCount: tree.overscanCount, itemKey: (index) => { var _a; return ((_a = tree.visibleNodes[index]) === null || _a === void 0 ? void 0 : _a.id) || index; }, outerElementType: ListOuterElement, innerElementType: ListInnerElement, onScroll: tree.props.onScroll, onItemsRendered: tree.onItemsRendered.bind(tree), ref: tree.list, children: RowContainer }) }));
+  useDataUpdates();
+  const tree = useTreeApi();
+  return _jsx("div", {
+    role: "tree",
+    style: {
+      height: tree.height,
+      width: tree.width,
+      minHeight: 0,
+      minWidth: 0,
+    },
+    onContextMenu: tree.props.onContextMenu,
+    onClick: tree.props.onClick,
+    tabIndex: 0,
+    onFocus: (e) => {
+      if (!e.currentTarget.contains(e.relatedTarget)) {
+        tree.onFocus();
+      }
+    },
+    onBlur: (e) => {
+      if (!e.currentTarget.contains(e.relatedTarget)) {
+        tree.onBlur();
+      }
+    },
+    onKeyDown: (e) => {
+      var _a;
+      if (tree.isEditing) {
+        return;
+      }
+      if (e.key === "Backspace") {
+        if (!tree.props.onDelete) return;
+        const ids = Array.from(tree.selectedIds);
+        if (ids.length > 1) {
+          let nextFocus = tree.mostRecentNode;
+          while (nextFocus && nextFocus.isSelected) {
+            nextFocus = nextFocus.nextSibling;
+          }
+          if (!nextFocus) nextFocus = tree.lastNode;
+          tree.focus(nextFocus, { scroll: false });
+          tree.delete(Array.from(ids));
+        } else {
+          const node = tree.focusedNode;
+          if (node) {
+            const sib = node.nextSibling;
+            const parent = node.parent;
+            tree.focus(sib || parent, { scroll: false });
+            tree.delete(node);
+          }
+        }
+        return;
+      }
+      if (e.key === "Tab" && !e.shiftKey) {
+        e.preventDefault();
+        focusNextElement(e.currentTarget);
+        return;
+      }
+      if (e.key === "Tab" && e.shiftKey) {
+        e.preventDefault();
+        focusPrevElement(e.currentTarget);
+        return;
+      }
+      if (e.key === "ArrowDown") {
+        e.preventDefault();
+        const next = tree.nextNode;
+        if (e.ctrlKey) {
+          tree.select(tree.focusedNode);
+          tree.activate(tree.focusedNode);
+          return;
+        } else if (!e.shiftKey || tree.props.disableMultiSelection) {
+          tree.focus(next);
+          return;
+        } else {
+          if (!next) return;
+          const current = tree.focusedNode;
+          if (!current) {
+            tree.focus(tree.firstNode);
+          } else if (current.isSelected) {
+            tree.selectContiguous(next);
+          } else {
+            tree.selectMulti(next);
+          }
+          return;
+        }
+      }
+      if (e.key === "ArrowUp") {
+        e.preventDefault();
+        const prev = tree.prevNode;
+        if (!e.shiftKey || tree.props.disableMultiSelection) {
+          tree.focus(prev);
+          return;
+        } else {
+          if (!prev) return;
+          const current = tree.focusedNode;
+          if (!current) {
+            tree.focus(tree.lastNode); // ?
+          } else if (current.isSelected) {
+            tree.selectContiguous(prev);
+          } else {
+            tree.selectMulti(prev);
+          }
+          return;
+        }
+      }
+      if (e.key === "ArrowRight") {
+        const node = tree.focusedNode;
+        if (!node) return;
+        if (node.isInternal && node.isOpen) {
+          tree.focus(tree.nextNode);
+        } else if (node.isInternal) tree.open(node.id);
+        return;
+      }
+      if (e.key === "ArrowLeft") {
+        const node = tree.focusedNode;
+        if (!node || node.isRoot) return;
+        if (node.isInternal && node.isOpen) tree.close(node.id);
+        else if (
+          !((_a = node.parent) === null || _a === void 0 ? void 0 : _a.isRoot)
+        ) {
+          tree.focus(node.parent);
+        }
+        return;
+      }
+      if (e.key === "a" && e.ctrlKey && !tree.props.disableMultiSelection) {
+        e.preventDefault();
+        tree.selectAll();
+        return;
+      }
+      if (e.key === "a" && !e.ctrlKey && tree.props.onCreate) {
+        tree.createLeaf();
+        return;
+      }
+      if (e.key === "A" && !e.ctrlKey) {
+        if (!tree.props.onCreate) return;
+        tree.createInternal();
+        return;
+      }
+      if (e.key === "Home") {
+        // add shift keys
+        e.preventDefault();
+        tree.focus(tree.firstNode);
+        return;
+      }
+      if (e.key === "End") {
+        // add shift keys
+        e.preventDefault();
+        tree.focus(tree.lastNode);
+        return;
+      }
+      if (e.key === "Enter") {
+        const node = tree.focusedNode;
+        if (!node) return;
+        if (!node.isEditable || !tree.props.onRename) return;
+        setTimeout(() => {
+          if (node) tree.edit(node);
+        });
+        return;
+      }
+      if (e.key === " ") {
+        e.preventDefault();
+        const node = tree.focusedNode;
+        if (!node) return;
+        if (node.isLeaf) {
+          node.select();
+          node.activate();
+        } else {
+          node.toggle();
+        }
+        return;
+      }
+      if (e.key === "*") {
+        const node = tree.focusedNode;
+        if (!node) return;
+        tree.openSiblings(node);
+        return;
+      }
+      if (e.key === "PageUp") {
+        e.preventDefault();
+        tree.pageUp();
+        return;
+      }
+      if (e.key === "PageDown") {
+        e.preventDefault();
+        tree.pageDown();
+      }
+      // If they type a sequence of characters
+      // collect them. Reset them after a timeout.
+      // Use it to search the tree for a node, then focus it.
+      // Clean this up a bit later
+      clearTimeout(timeoutId);
+      focusSearchTerm += e.key;
+      timeoutId = setTimeout(() => {
+        focusSearchTerm = "";
+      }, 600);
+      const node = tree.visibleNodes.find((n) => {
+        // @ts-ignore
+        const name = n.data.name;
+        if (typeof name === "string") {
+          return name.toLowerCase().startsWith(focusSearchTerm);
+        } else return false;
+      });
+      if (node) tree.focus(node.id);
+    },
+    children: _jsx(FixedSizeList, {
+      className: tree.props.className,
+      outerRef: tree.listEl,
+      itemCount: tree.visibleNodes.length,
+      height: tree.height,
+      width: tree.width,
+      itemSize: tree.rowHeight,
+      overscanCount: tree.overscanCount,
+      itemKey: (index) => {
+        var _a;
+        return (
+          ((_a = tree.visibleNodes[index]) === null || _a === void 0
+            ? void 0
+            : _a.id) || index
+        );
+      },
+      outerElementType: ListOuterElement,
+      innerElementType: ListInnerElement,
+      onScroll: tree.props.onScroll,
+      onItemsRendered: tree.onItemsRendered.bind(tree),
+      ref: tree.list,
+      children: RowContainer,
+    }),
+  });
 }
diff --git a/dist/module/interfaces/node-api.js b/dist/module/interfaces/node-api.js
index 484fe0a6fb5f0821741a50b8a06720f01e67c478..36a0fb13238e06f6412e04d75e715bc46b1b45b5 100644
--- a/dist/module/interfaces/node-api.js
+++ b/dist/module/interfaces/node-api.js
@@ -1,160 +1,164 @@
 import { ROOT_ID } from "../data/create-root";
 export class NodeApi {
-    constructor(params) {
-        this.handleClick = (e) => {
-            if (e.metaKey && !this.tree.props.disableMultiSelection) {
-                this.isSelected ? this.deselect() : this.selectMulti();
-            }
-            else if (e.shiftKey && !this.tree.props.disableMultiSelection) {
-                this.selectContiguous();
-            }
-            else {
-                this.select();
-                this.activate();
-            }
-        };
-        this.tree = params.tree;
-        this.id = params.id;
-        this.data = params.data;
-        this.level = params.level;
-        this.children = params.children;
-        this.parent = params.parent;
-        this.isDraggable = params.isDraggable;
-        this.rowIndex = params.rowIndex;
-    }
-    get isRoot() {
-        return this.id === ROOT_ID;
-    }
-    get isLeaf() {
-        return !Array.isArray(this.children);
-    }
-    get isInternal() {
-        return !this.isLeaf;
-    }
-    get isOpen() {
-        return this.isLeaf ? false : this.tree.isOpen(this.id);
-    }
-    get isClosed() {
-        return this.isLeaf ? false : !this.tree.isOpen(this.id);
-    }
-    get isEditable() {
-        return this.tree.isEditable(this.data);
-    }
-    get isEditing() {
-        return this.tree.editingId === this.id;
-    }
-    get isSelected() {
-        return this.tree.isSelected(this.id);
-    }
-    get isOnlySelection() {
-        return this.isSelected && this.tree.hasOneSelection;
-    }
-    get isSelectedStart() {
-        var _a;
-        return this.isSelected && !((_a = this.prev) === null || _a === void 0 ? void 0 : _a.isSelected);
-    }
-    get isSelectedEnd() {
-        var _a;
-        return this.isSelected && !((_a = this.next) === null || _a === void 0 ? void 0 : _a.isSelected);
-    }
-    get isFocused() {
-        return this.tree.isFocused(this.id);
-    }
-    get isDragging() {
-        return this.tree.isDragging(this.id);
-    }
-    get willReceiveDrop() {
-        return this.tree.willReceiveDrop(this.id);
-    }
-    get state() {
-        return {
-            isClosed: this.isClosed,
-            isDragging: this.isDragging,
-            isEditing: this.isEditing,
-            isFocused: this.isFocused,
-            isInternal: this.isInternal,
-            isLeaf: this.isLeaf,
-            isOpen: this.isOpen,
-            isSelected: this.isSelected,
-            isSelectedEnd: this.isSelectedEnd,
-            isSelectedStart: this.isSelectedStart,
-            willReceiveDrop: this.willReceiveDrop,
-        };
-    }
-    get childIndex() {
-        if (this.parent && this.parent.children) {
-            return this.parent.children.findIndex((child) => child.id === this.id);
-        }
-        else {
-            return -1;
-        }
-    }
-    get next() {
-        if (this.rowIndex === null)
-            return null;
-        return this.tree.at(this.rowIndex + 1);
-    }
-    get prev() {
-        if (this.rowIndex === null)
-            return null;
-        return this.tree.at(this.rowIndex - 1);
-    }
-    get nextSibling() {
-        var _a, _b;
-        const i = this.childIndex;
-        return (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children[i + 1]) !== null && _b !== void 0 ? _b : null;
-    }
-    isAncestorOf(node) {
-        if (!node)
-            return false;
-        let ancestor = node;
-        while (ancestor) {
-            if (ancestor.id === this.id)
-                return true;
-            ancestor = ancestor.parent;
-        }
-        return false;
-    }
-    select() {
-        this.tree.select(this);
-    }
-    deselect() {
-        this.tree.deselect(this);
-    }
-    selectMulti() {
-        this.tree.selectMulti(this);
-    }
-    selectContiguous() {
-        this.tree.selectContiguous(this);
-    }
-    activate() {
-        this.tree.activate(this);
-    }
-    focus() {
-        this.tree.focus(this);
-    }
-    toggle() {
-        this.tree.toggle(this);
-    }
-    open() {
-        this.tree.open(this);
-    }
-    openParents() {
-        this.tree.openParents(this);
-    }
-    close() {
-        this.tree.close(this);
-    }
-    submit(value) {
-        this.tree.submit(this, value);
-    }
-    reset() {
-        this.tree.reset();
-    }
-    clone() {
-        return new NodeApi(Object.assign({}, this));
-    }
-    edit() {
-        return this.tree.edit(this);
-    }
+  constructor(params) {
+    this.handleClick = (e) => {
+      if (e.ctrlKey && !this.tree.props.disableMultiSelection) {
+        this.isSelected ? this.deselect() : this.selectMulti();
+      } else if (e.shiftKey && !this.tree.props.disableMultiSelection) {
+        this.selectContiguous();
+      } else {
+        this.select();
+        this.activate();
+      }
+    };
+    this.tree = params.tree;
+    this.id = params.id;
+    this.data = params.data;
+    this.level = params.level;
+    this.children = params.children;
+    this.parent = params.parent;
+    this.isDraggable = params.isDraggable;
+    this.rowIndex = params.rowIndex;
+  }
+  get isRoot() {
+    return this.id === ROOT_ID;
+  }
+  get isLeaf() {
+    return !Array.isArray(this.children);
+  }
+  get isInternal() {
+    return !this.isLeaf;
+  }
+  get isOpen() {
+    return this.isLeaf ? false : this.tree.isOpen(this.id);
+  }
+  get isClosed() {
+    return this.isLeaf ? false : !this.tree.isOpen(this.id);
+  }
+  get isEditable() {
+    return this.tree.isEditable(this.data);
+  }
+  get isEditing() {
+    return this.tree.editingId === this.id;
+  }
+  get isSelected() {
+    return this.tree.isSelected(this.id);
+  }
+  get isOnlySelection() {
+    return this.isSelected && this.tree.hasOneSelection;
+  }
+  get isSelectedStart() {
+    var _a;
+    return (
+      this.isSelected &&
+      !((_a = this.prev) === null || _a === void 0 ? void 0 : _a.isSelected)
+    );
+  }
+  get isSelectedEnd() {
+    var _a;
+    return (
+      this.isSelected &&
+      !((_a = this.next) === null || _a === void 0 ? void 0 : _a.isSelected)
+    );
+  }
+  get isFocused() {
+    return this.tree.isFocused(this.id);
+  }
+  get isDragging() {
+    return this.tree.isDragging(this.id);
+  }
+  get willReceiveDrop() {
+    return this.tree.willReceiveDrop(this.id);
+  }
+  get state() {
+    return {
+      isClosed: this.isClosed,
+      isDragging: this.isDragging,
+      isEditing: this.isEditing,
+      isFocused: this.isFocused,
+      isInternal: this.isInternal,
+      isLeaf: this.isLeaf,
+      isOpen: this.isOpen,
+      isSelected: this.isSelected,
+      isSelectedEnd: this.isSelectedEnd,
+      isSelectedStart: this.isSelectedStart,
+      willReceiveDrop: this.willReceiveDrop,
+    };
+  }
+  get childIndex() {
+    if (this.parent && this.parent.children) {
+      return this.parent.children.findIndex((child) => child.id === this.id);
+    } else {
+      return -1;
+    }
+  }
+  get next() {
+    if (this.rowIndex === null) return null;
+    return this.tree.at(this.rowIndex + 1);
+  }
+  get prev() {
+    if (this.rowIndex === null) return null;
+    return this.tree.at(this.rowIndex - 1);
+  }
+  get nextSibling() {
+    var _a, _b;
+    const i = this.childIndex;
+    return (_b =
+      (_a = this.parent) === null || _a === void 0
+        ? void 0
+        : _a.children[i + 1]) !== null && _b !== void 0
+      ? _b
+      : null;
+  }
+  isAncestorOf(node) {
+    if (!node) return false;
+    let ancestor = node;
+    while (ancestor) {
+      if (ancestor.id === this.id) return true;
+      ancestor = ancestor.parent;
+    }
+    return false;
+  }
+  select() {
+    this.tree.select(this);
+  }
+  deselect() {
+    this.tree.deselect(this);
+  }
+  selectMulti() {
+    this.tree.selectMulti(this);
+  }
+  selectContiguous() {
+    this.tree.selectContiguous(this);
+  }
+  activate() {
+    this.tree.activate(this);
+  }
+  focus() {
+    this.tree.focus(this);
+  }
+  toggle() {
+    this.tree.toggle(this);
+  }
+  open() {
+    this.tree.open(this);
+  }
+  openParents() {
+    this.tree.openParents(this);
+  }
+  close() {
+    this.tree.close(this);
+  }
+  submit(value) {
+    this.tree.submit(this, value);
+  }
+  reset() {
+    this.tree.reset();
+  }
+  clone() {
+    return new NodeApi(Object.assign({}, this));
+  }
+  edit() {
+    return this.tree.edit(this);
+  }
 }
diff --git a/src/components/default-container.tsx b/src/components/default-container.tsx
index f92dd5cfe7463bbdb775f87afffb4052fe0d90db..3911c2b1a9a96c8fa45e318a02e99ba8112a8200 100644
--- a/src/components/default-container.tsx
+++ b/src/components/default-container.tsx
@@ -77,7 +77,7 @@ export function DefaultContainer() {
         if (e.key === "ArrowDown") {
           e.preventDefault();
           const next = tree.nextNode;
-          if (e.metaKey) {
+          if (e.ctrlKey) {
             tree.select(tree.focusedNode);
             tree.activate(tree.focusedNode);
             return;
@@ -133,16 +133,16 @@ export function DefaultContainer() {
           }
           return;
         }
-        if (e.key === "a" && e.metaKey && !tree.props.disableMultiSelection) {
+        if (e.key === "a" && e.ctrlKey && !tree.props.disableMultiSelection) {
           e.preventDefault();
           tree.selectAll();
           return;
         }
-        if (e.key === "a" && !e.metaKey && tree.props.onCreate) {
+        if (e.key === "a" && !e.ctrlKey && tree.props.onCreate) {
           tree.createLeaf();
           return;
         }
-        if (e.key === "A" && !e.metaKey) {
+        if (e.key === "A" && !e.ctrlKey) {
           if (!tree.props.onCreate) return;
           tree.createInternal();
           return;
diff --git a/src/interfaces/node-api.ts b/src/interfaces/node-api.ts
index 34d713833817d8136ff059526da1dd7a72317811..8449090b7ec11672bfc44abeacff0fbc6888632b 100644
--- a/src/interfaces/node-api.ts
+++ b/src/interfaces/node-api.ts
@@ -197,7 +197,7 @@ export class NodeApi<T = any> {
   }
 
   handleClick = (e: React.MouseEvent) => {
-    if (e.metaKey && !this.tree.props.disableMultiSelection) {
+    if (e.ctrlKey && !this.tree.props.disableMultiSelection) {
       this.isSelected ? this.deselect() : this.selectMulti();
     } else if (e.shiftKey && !this.tree.props.disableMultiSelection) {
       this.selectContiguous();
